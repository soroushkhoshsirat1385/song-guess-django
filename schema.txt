# Database Schema (Song Guessing Game)

This document describes the **current database schema** as implemented by the Django project under `backend/server/`.

Notes:
- Table names below follow Django’s default naming convention: `<app_label>_<modelname>`.
- Primary keys are Django default `id` fields (typically `BigAutoField`) unless stated otherwise.
- “FK” indicates a foreign key.
- Built-in Django tables are listed first (core for auth/sessions/admin).

---

## 1) Django built-in tables (core)

### django_migrations
Tracks applied migrations.
- id (PK)
- app (varchar)
- name (varchar)
- applied (datetime)

### django_content_type
- id (PK)
- app_label (varchar)
- model (varchar)
- Unique(app_label, model)

### auth_permission
- id (PK)
- name (varchar)
- content_type_id (FK → django_content_type.id)
- codename (varchar)
- Unique(content_type_id, codename)

### auth_group
- id (PK)
- name (varchar, unique)

### auth_group_permissions (M2M)
- id (PK)
- group_id (FK → auth_group.id)
- permission_id (FK → auth_permission.id)
- Unique(group_id, permission_id)

### auth_user
Django’s built-in user model (since we have not introduced a custom one yet).
- id (PK)
- password (varchar)
- last_login (datetime, nullable)
- is_superuser (bool)
- username (varchar, unique)
- first_name (varchar)
- last_name (varchar)
- email (varchar)
- is_staff (bool)
- is_active (bool)
- date_joined (datetime)

### auth_user_groups (M2M)
- id (PK)
- user_id (FK → auth_user.id)
- group_id (FK → auth_group.id)
- Unique(user_id, group_id)

### auth_user_user_permissions (M2M)
- id (PK)
- user_id (FK → auth_user.id)
- permission_id (FK → auth_permission.id)
- Unique(user_id, permission_id)

### django_admin_log
Admin audit log.
- id (PK)
- action_time (datetime)
- user_id (FK → auth_user.id)
- content_type_id (FK → django_content_type.id, nullable)
- object_id (text, nullable)
- object_repr (varchar)
- action_flag (smallint)
- change_message (text)

### django_session
Session storage (used for session-based auth).
- session_key (PK, varchar)
- session_data (text)
- expire_date (datetime)

---

## 2) Game app tables (`game`)

All of the following are implemented in `backend/server/game/models.py`.

### game_room
Represents a room/lobby.
- id (PK)
- code (varchar(12), unique)  
  - generated by `generate_room_code()` (default length 6, stored up to 12)
- name (varchar(120), blank allowed)
- created_at (datetime)

Indexes/constraints:
- Unique(code)

### game_roommember
Room membership + cached score.
- id (PK)
- room_id (FK → game_room.id, on delete CASCADE)
- user_id (FK → auth_user.id, on delete CASCADE)
- joined_at (datetime)
- score (int, default 0)

Indexes/constraints:
- Unique(room_id, user_id)  (constraint name: `uniq_room_member`)

### game_round
A round within a room.
- id (PK)
- room_id (FK → game_room.id, on delete CASCADE)
- index (positive int, default 1)
- started_at (datetime, nullable)
- ended_at (datetime, nullable)

Indexes/constraints:
- Unique(room_id, index)  (constraint name: `uniq_room_round_index`)

### game_songsubmission
A song submitted by a user for a given round.
- id (PK)
- round_id (FK → game_round.id, on delete CASCADE)
- uploader_id (FK → auth_user.id, on delete CASCADE)
- file (varchar path; Django FileField, upload_to = room/round-scoped path)
- original_filename (varchar(255), blank allowed)
- created_at (datetime)

Indexes/constraints:
- Unique(round_id, uploader_id)  (constraint name: `uniq_round_uploader_submission`)

### game_guess
A user’s guess for a specific submission.
- id (PK)
- submission_id (FK → game_songsubmission.id, on delete CASCADE)
- guesser_id (FK → auth_user.id, on delete CASCADE)
- guessed_uploader_id (FK → auth_user.id, nullable, on delete SET NULL)
- created_at (datetime)

Indexes/constraints:
- Unique(submission_id, guesser_id)  (constraint name: `uniq_guess_per_submission_per_user`)

Derived fields/logic:
- `is_correct` is computed as:
  - guessed_uploader_id != NULL AND guessed_uploader_id == submission.uploader_id

### game_roundsong
**Persisted randomized play order** for a round.
- id (PK)
- round_id (FK → game_round.id, on delete CASCADE)
- submission_id (OneToOne FK → game_songsubmission.id, on delete CASCADE)
- order_index (positive int)
- played_at (datetime, nullable)

Indexes/constraints:
- Unique(round_id, order_index)  (constraint name: `uniq_round_order_index`)
- OneToOne(submission_id) ensures each submission appears at most once in a round’s play order

### game_scoreevent
Append-only scoring ledger (audit/premium logging).
- id (PK)
- room_id (FK → game_room.id, on delete CASCADE)
- round_id (FK → game_round.id, on delete CASCADE)
- user_id (FK → auth_user.id, on delete CASCADE)
- event_type (varchar(32), enum-ish)
  - allowed values (currently):
    - correct_guess
    - unguessed_song
- points (int)
- metadata (JSON)
- created_at (datetime)

Indexes/constraints:
- (No unique constraints currently; multiple events per user/round are allowed by design)

---

## 3) Current scoring rules (as implemented)
When revealing a round (`reveal_and_score_round` in `backend/server/game/services.py`):
- +2 points to the guesser for each correct guess
- +3 points to the uploader if nobody guessed their song correctly

The system:
- updates `game_roommember.score` (cached total for fast leaderboard)
- inserts rows into `game_scoreevent` (ledger for audit/premium logs)

---

## 4) Suggested next schema additions (not implemented yet)
If you want a room to host multiple games over time and support richer analytics:
- GameSession/Match table (room + status + start/end)
- RoundState table (phase/timers)
- SubmissionPlayback table (exact timestamps, who listened when)
- PremiumLog snapshots per round/game
